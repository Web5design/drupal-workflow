<?php
// $Id: workflow.module,v 1.83.2.14.2.3 2010/08/30 21:44:26 q0rban Exp $

/**
 * @file
 * Support workflows made up of arbitrary states.
 */

define('WORKFLOW_CREATION', 1);
define('WORKFLOW_CREATION_NAME', 'creation');
define('WORKFLOW_CREATION_DEFAULT_WEIGHT', -50);
define('WORKFLOW_DELETION', 0);
define('WORKFLOW_ARROW', '&#8594;');

/**
 * Implementation of hook_help().
 */
function workflow_help($path, $arg) {
  switch ($path) {
    case 'admin/build/workflow/edit/%':
      return t('You are currently viewing the possible transitions to and from workflow states. The state is shown in the left column; the state to be moved to is to the right. For each transition, check the box next to the role(s) that may initiate the transition. For example, if only the "production editor" role may move a node from Review state to the Published state, check the box next to "production editor". The author role is built in and refers to the user who authored the node.');
    case 'admin/build/workflow/add':
      return t('To get started, provide a name for your workflow. This name will be used as a label when the workflow status is shown during node editing.');
    case 'admin/build/workflow/state':
      return t('Enter the name for a state in your workflow. For example, if you were doing a meal workflow it may include states like <em>shop</em>, <em>prepare</em>, <em>eat</em>, and <em>clean up</em>.');
    case 'admin/build/trigger/workflow':
      return t('Use this page to set actions to happen when transitions occur. To configure actions, use the <a href="@link">actions settings page</a>.', array('@link' => url('admin/settings/actions')));
  }
}

/**
 * Implementation of hook_perm().
 */
function workflow_perm() {
  return array('administer workflow', 'schedule workflow transitions', 'access workflow summary views');
}

/**
 * Implementation of hook_menu().
 */
function workflow_menu() {
  $items['admin/build/workflow'] = array(
    'title' => 'Workflow',
    'access arguments' => array('administer workflow'),
    'page callback' => 'workflow_overview',
    'description' => 'Allows the creation and assignment of arbitrary workflows to node types.',
    'file' => 'workflow.admin.inc',
  );
  $items['admin/build/workflow/edit/%workflow'] = array(
    'title' => 'Edit workflow',
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer workflow'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workflow_edit_form', 4),
    'file' => 'workflow.admin.inc',
  );
  $items['admin/build/workflow/list'] = array(
    'title' => 'List',
    'weight' => -10,
    'access arguments' => array('administer workflow'),
    'page callback' => 'workflow_overview',
    'file' => 'workflow.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/build/workflow/add'] = array(
    'title' => 'Add workflow',
    'weight' => -8,
    'access arguments' => array('administer workflow'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workflow_add_form'),
    'file' => 'workflow.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/build/workflow/state/delete'] = array(
    'title' => 'Delete State',
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer workflow'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workflow_state_delete_form'),
    'file' => 'workflow.admin.inc',
  );
  $items['admin/build/workflow/delete'] = array(
    'title' => 'Delete workflow',
    'type' => MENU_CALLBACK,
    'access arguments' => array('administer workflow'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workflow_delete_form'),
    'file' => 'workflow.admin.inc',
  );
  $items['node/%node/workflow'] = array(
    'title' => 'Workflow',
    'type' => MENU_LOCAL_TASK,
    'access callback' => 'workflow_node_tab_access',
    'access arguments' => array(1),
    'page callback' => 'workflow_tab_page',
    'page arguments' => array(1),
    'file' => 'workflow.pages.inc',
    'weight' => 2,
  );
  return $items;
}

/**
 * Menu access control callback. Determine access to Workflow tab.
 */
function workflow_node_tab_access($node = NULL) {
  global $user;
  $name = workflow_get_workflow_for_type($node->type);
  if ($name === FALSE) {
    // No workflow associated with this node type.
    return FALSE;
  }
  $roles = array_keys($user->roles);
  if ($node->uid == $user->uid) {
    $roles = array_merge(array('author'), $roles);
  }
  $workflow = workflow_load($name);
  $allowed_roles = $workflow->tab_roles ? explode(',', $workflow->tab_roles) : array();

  if (user_access('administer nodes') || array_intersect($roles, $allowed_roles)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implementation of hook_theme().
 */
function workflow_theme() {
  return array(
    'workflow_edit_form' => array(
      'arguments' => array(
        'form' => array(),
      ),
    ),
    'workflow_states_form' => array(
      'arguments' => array(
        'form' => array(),
      ),
    ),
    'workflow_types_form' => array(
      'arguments' => array(
        'form' => array(),
      ),
    ),
    'workflow_actions_form' => array(
      'arguments' => array(
        'form' => array()
      ),
    ),
    'workflow_history_table_row' => array(
      'arguments' => array(
        'history' => NULL,
        'old_state_name' => NULL,
        'state_name' => null
      ),
    ),
    'workflow_history_table' => array(
      'arguments' => array(
        'rows' => array(),
        'footer' => NULL,
      ),
    ),
    'workflow_current_state' => array(
      'arguments' => array(
        'label' => NULL,
      ),
    ),
    'workflow_deleted_state' => array(
      'arguments' => array(
        'label' => NULL,
      ),
    ),
    'workflow_permissions' => array(
      'arguments' => array(
        'header' => array(),
        'all' => array(),
      ),
    ),
  );
}

/**
 * Implementation of hook_forms().
 */
function workflow_forms() {
  $forms = array();
  foreach (workflow_get_all() as $workflow_name => $workflow) {
    $forms['workflow_states_form_'. $workflow_name]['callback'] = 'workflow_states_form';
  }
  return $forms;
}

/**
 * Implementation of hook_views_api().
 */
function workflow_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'workflow') .'/includes',
  );
}

/**
 * Implementation of hook_nodeapi().
 */
function workflow_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  switch ($op) {
    case 'load':
      $node->_workflow = workflow_node_current_state($node);

      // Add scheduling information.
      $res = db_query('SELECT * FROM {workflow_scheduled_transition} WHERE nid = %d', $node->nid);
      if ($row = db_fetch_object($res)) {
        $node->_workflow_scheduled_state_name = $row->state_name;
        $node->_workflow_scheduled_timestamp = $row->scheduled;
        $node->_workflow_scheduled_comment = $row->comment;
      }
      break;

    case 'insert':
      // If the state is not specified, use first valid state.
      // For example, a new node must move from (creation) to some
      // initial state.
      if (empty($node->workflow)) {
        $choices = workflow_field_choices($node);
        $keys = array_keys($choices);
        $state_name = array_shift($keys);
      }
      // Note no break; fall through to 'update' case.
    case 'update':
      // Do nothing if there is no workflow for this node type.
      $name = workflow_get_workflow_for_type($node->type);
      if (!$name) {
        break;
      }

      // Get new state from value of workflow form field, stored in $node->workflow.
      if (!isset($state_name)) {
        $state_name = $node->workflow;
      }

      workflow_transition($node, $state_name);
      break;

    case 'delete':
      db_query("DELETE FROM {workflow_node} WHERE nid = %d", $node->nid);
      _workflow_write_history($node, WORKFLOW_DELETION, t('Node deleted'));
      // Delete any scheduled transitions for this node.
      db_query("DELETE FROM {workflow_scheduled_transition} WHERE nid = %d", $node->nid);
      break;
  }
}

/**
 * Implementation of hook_comment().
 */
function workflow_comment($a1, $op) {
  if (($op == 'insert' || $op == 'update') && isset($a1['workflow'])) {
    $node = node_load($a1['nid']);
    $state_name = $a1['workflow'];
    $node->workflow_comment = $a1['workflow_comment'];
    if (isset($a1['workflow_scheduled'])) {
      $node->workflow_scheduled = $a1['workflow_scheduled'];
      $node->workflow_scheduled_date = $a1['workflow_scheduled_date'];
      $node->workflow_scheduled_hour = $a1['workflow_scheduled_hour'];
    }
    workflow_transition($node, $state_name);
  }
}

/**
 * Validate target state and either execute a transition immediately or schedule
 * a transition to be executed later by cron.
 *
 * @param $node
 * @param $state_name
 *   The machine name of the target state
 */
function workflow_transition($node, $state_name) {
  // Make sure new state is a valid choice.
  if (array_key_exists($state_name, workflow_field_choices($node))) {
    if (!$node->workflow_scheduled) {
      // It's an immediate change. Do the transition.
      workflow_execute_transition($node, $state_name, isset($node->workflow_comment) ? $node->workflow_comment : NULL);
    }
    else {
      // Schedule the the time to change the state.
      $comment = $node->workflow_comment;
      $old_state_name = workflow_node_current_state($node);

      if ($node->workflow_scheduled_date['day'] < 10) {
        $node->workflow_scheduled_date['day'] = '0' .
        $node->workflow_scheduled_date['day'];
      }

      if ($node->workflow_scheduled_date['month'] < 10) {
        $node->workflow_scheduled_date['month'] = '0' .
        $node->workflow_scheduled_date['month'];
      }

      if (!$node->workflow_scheduled_hour) {
        $node->workflow_scheduled_hour = '00:00';
      }

      $scheduled = $node->workflow_scheduled_date['year'] . $node->workflow_scheduled_date['month'] . $node->workflow_scheduled_date['day'] . ' ' . $node->workflow_scheduled_hour . 'Z';
      if ($scheduled = strtotime($scheduled)) {
        // Adjust for user and site timezone settings.
        global $user;
        if (variable_get('configurable_timezones', 1) && $user->uid && strlen($user->timezone)) {
          $timezone = $user->timezone;
        }
        else {
          $timezone = variable_get('date_default_timezone', 0);
        }
        $scheduled = $scheduled - $timezone;

        // Clear previous entries and insert.
        db_query("DELETE FROM {workflow_scheduled_transition} WHERE nid = %d", $node->nid);
        db_query("INSERT INTO {workflow_scheduled_transition} (nid, old_state_name, state_name, scheduled, comment) VALUES (%d, '%s', '%s', %d, '%s')", $node->nid, $old_state_name, $state_name, $scheduled, $comment);

        $t_args = array(
          '@node_title' => $node->title,
          '%state_name' => workflow_get_state_label($state_name),
          '!scheduled_date' => format_date($scheduled),
        );
        watchdog('workflow', '@node_title scheduled for state change to %state_name on !scheduled_date', $t_args, WATCHDOG_NOTICE, l('view', "node/$node->nid/workflow"));
        drupal_set_message(t('@node_title is scheduled for state change to %state_name on !scheduled_date', $t_args));
      }
    }
  }
}

/**
 * Form builder. Add form widgets for workflow change to $form.
 *
 * This builder is factored out of workflow_form_alter() because
 * it is also used on the Workflow tab.
 *
 * @param $form
 *   An existing form definition array.
 * @param $title
 *   The translated and sanitized title of the state field.
 * @param $name
 *   The machine name of the workflow.
 * @param $default_value
 *   The machine name for the default state.
 * @param $choices
 *   An array of possible target states.
 * @param $timestamp
 *   Optional timestamp of the scheduled state transition.
 * @param $comment
 *   Optional comment of the scheduled state transition.
 */
function workflow_node_form(&$form, $form_state, $title, $name, $default_value, $choices, $timestamp = NULL, $comment = NULL) {
  // No sense displaying choices if there is only one choice.
  if (sizeof($choices) == 1) {
    $form['workflow'][$name] = array(
      '#type' => 'hidden',
      '#value' => $default_value,
    );
  }
  else {
    $form['workflow'][$name] = array(
      '#type' => 'radios',
      '#title' => $title,
      '#options' => $choices,
      '#name' => $name,
      '#parents' => array('workflow'),
      '#default_value' => $default_value,
    );

    // Display scheduling form only if a node is being edited and user has
    // permission. State change cannot be scheduled at node creation because
    // that leaves the node in the (creation) state.
    if (!(arg(0) == 'node' && arg(1) == 'add') && user_access('schedule workflow transitions')) {
      $scheduled = $timestamp ? 1 : 0;
      $timestamp = $scheduled ? $timestamp : time();

      $form['workflow']['workflow_scheduled'] = array(
        '#type' => 'radios',
        '#title' => t('Schedule'),
        '#options' => array(
          t('Immediately'),
          t('Schedule for state change at:'),
        ),
        '#default_value' => isset($form_state['values']['workflow_scheduled']) ? $form_state['values']['workflow_scheduled'] : $scheduled,
      );

      $sched_date = $form_state['values']['workflow_scheduled_date'];

      $form['workflow']['workflow_scheduled_date'] = array(
        '#type' => 'date',
        '#default_value' => array(
          'day'   => isset($sched_date['day']) ? $sched_date['day'] : format_date($timestamp, 'custom', 'j'),
          'month' => isset($sched_date['month']) ? $sched_date['month'] : format_date($timestamp, 'custom', 'n'),
          'year'  => isset($sched_date['year']) ? $sched_date['year'] : format_date($timestamp, 'custom', 'Y')
        ),
      );

      // Set up the hour field.
      $sched_hour = isset($form_state['values']['workflow_scheduled_hour']) ? $form_state['values']['workflow_scheduled_hour'] : format_date($timestamp, 'custom', 'H:i');
      $description = 'Please enter a time in 24 hour (eg. HH:MM) format. If no time is included, the default will be midnight on the specified date. The current time is: %time';
      $t_args = array('%time' => format_date(time()));

      $form['workflow']['workflow_scheduled_hour'] = array(
        '#type' => 'textfield',
        '#description' => t($description, $t_args),
        '#default_value' => $scheduled ? $sched_hour : NULL,
      );
    }
    if (isset($form['#tab'])) {
      $determiner = 'comment_log_tab';
    }
    else {
      $determiner = 'comment_log_node';
    }
    $form['workflow']['workflow_comment'] = array(
      '#type' => $form['#wf']->options[$determiner] ? 'textarea': 'hidden',
      '#title' => t('Comment'),
      '#description' => t('A comment to put in the workflow log.'),
      '#default_value' => $comment,
      '#rows' => 2,
    );
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * @param object &$node
 * @return array
 */
function workflow_form_alter(&$form, $form_state, $form_id) {
  // Ignore all forms except comment forms and node editing forms.
  if ($form_id == 'comment_form' || (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id)) {
    if (isset($form['#node'])) {
      $node = $form['#node'];
      // Abort if no workflow is assigned to this node type.
      if (!($name = workflow_get_workflow_for_type($node->type))) {
        return;
      }
    }
    else {
      $type = db_result(db_query("SELECT type FROM {node} WHERE nid = %d", $form['nid']['#value']));
      // Abort if user does not want to display workflow form on node editing form.
      if (!in_array('comment', variable_get('workflow_' . $type, array('node')))) {
        return;
      }
      $node = node_load($form['nid']['#value']);
    }

    $choices = workflow_field_choices($node);
    $name = workflow_get_workflow_for_type($node->type);
    $states = workflow_get_states($name);

    // If this is a preview, the current state should come from the form values,
    // not the node, as the user may have changed the state.
    $default_value = isset($form_state['values']['workflow']) ? $form_state['values']['workflow'] : workflow_node_current_state($node);
    $min = ($default_value == _workflow_creation_state($name)) ? 1 : 2;
    // Stop if user has no new target state(s) to choose.
    if (count($choices) < $min) {
      return;
    }

    $workflow = workflow_load($name);
    $form['#wf'] = $workflow;

    // If the current node state is not one of the choices, autoselect first choice.
    // We know all states in $choices are states that user has permission to
    // go to because workflow_field_choices() has already checked that.
    if (!isset($choices[$default_value])) {
      $array = array_keys($choices);
      $default_value = $array[0];
    }

    if (sizeof($choices) > 1) {
      $form['workflow'] = array(
        '#type' => 'fieldset',
        '#title' => $workflow->label,
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
        '#weight' => 10,
      );
    }

    $timestamp = NULL;
    $comment = '';

    // See if scheduling information is present.
    if (isset($node->_workflow_scheduled_timestamp) && isset($node->_workflow_scheduled_state_name)) {
      // The default value should be the upcoming state_name.
      $default_value = $node->_workflow_scheduled_state_name;
      $timestamp = $node->_workflow_scheduled_timestamp;
      $comment = $node->_workflow_scheduled_comment;
    }

    if (isset($form_state['values']['workflow_comment'])) {
      $comment = $form_state['values']['workflow_comment'];
    }

    workflow_node_form($form, $form_state, $workflow->label, $name, $default_value, $choices, $timestamp, $comment);
  }
}

/**
 * Execute a transition (change state of a node).
 *
 * @param $node
 * @param $state_name
 *   The machine name of the target state.
 * @param $comment
 *   A comment for the node's workflow history.
 * @param $force
 *   If set to TRUE, workflow permissions will be ignored.
 *
 * @return int
 *   ID of new state.
 */
function workflow_execute_transition($node, $state_name, $comment = NULL, $force = FALSE) {
  global $user;
  $old_state = workflow_node_current_state($node);
  if ($old_state == $state_name) {
    // Stop if not going to a different state.
    // Write comment into history though.
    if ($comment && !$node->_workflow_scheduled_comment) {
      $node->workflow_stamp = time();
      db_query("UPDATE {workflow_node} SET stamp = %d WHERE nid = %d", $node->workflow_stamp, $node->nid);
      $result = module_invoke_all('workflow', 'transition pre', $old_state, $state_name, $node);
      _workflow_write_history($node, $state_name, $comment);
      unset($node->workflow_comment);

      $result = module_invoke_all('workflow', 'transition post', $old_state, $state_name, $node);
      // Rules integration
      if (module_exists('rules')) {
        rules_invoke_event('workflow_comment_added', $node, $old_state, $state_name);
      }
    }
    return;
  }

  $tid = workflow_get_transition_id($old_state, $state_name);
  if (!$tid && !$force) {
      watchdog('workflow', 'Attempt to go to nonexistent transition (from %old to %new)', array('%old' => $old_state, '%new' => $state_name, WATCHDOG_ERROR));
      return;
  }
  // Make sure this transition is valid and allowed for the current user.
  // Check allowability of state change if user is not superuser (might be cron).
  if (($user->uid != 1) && !$force) {
    if (!workflow_transition_allowed($tid, array_merge(array_keys($user->roles), array('author')))) {
      watchdog('workflow', 'User %user not allowed to go from state %old to %new', array('%user' => $user->name, '%old' => $old_state, '%new' => $state_name, WATCHDOG_NOTICE));
      return;
    }
  }
  // Invoke a callback indicating a transition is about to occur. Modules
  // may veto the transition by returning FALSE.
  $result = module_invoke_all('workflow', 'transition pre', $old_state, $state_name, $node);

  // Stop if a module says so.
  if (in_array(FALSE, $result)) {
    watchdog('workflow', 'Transition vetoed by module.');
    return;
  }

  // If the node does not have an existing $node->_workflow property, save
  // the $old_state there so _workflow_write_history() can log it.
  if (!isset($node->_workflow)) {
    $node->_workflow = $old_state;
  }
  // Change the state.
  _workflow_node_to_state($node, $state_name, $comment);
  $node->_workflow = $state_name;

  // Register state change with watchdog.
  $state_label = workflow_get_state_label($state_name);
  $type = node_get_types('name', $node->type);
  watchdog('workflow', 'State of @type %node_title set to %state_name', array('@type' => $type, '%node_title' => $node->title, '%state_name' => $state_label), WATCHDOG_NOTICE, l('view', 'node/' . $node->nid));

  // Notify modules that transition has occurred. Actions should take place
  // in response to this callback, not the previous one.
  module_invoke_all('workflow', 'transition post', $old_state, $state_name, $node);

  // Clear any references in the scheduled listing.
  db_query('DELETE FROM {workflow_scheduled_transition} WHERE nid = %d', $node->nid);

  // Rules integration
  if (module_exists('rules')) {
    rules_invoke_event('workflow_state_changed', $node, $old_state, $state_name);
  }

  return $state_name;
}

/**
 * Implementation of hook_action_info().
 */
function workflow_action_info() {
  return array(
    'workflow_select_next_state_action' => array(
      'type' => 'node',
      'description' => t('Change workflow state of post to next state'),
      'configurable' => FALSE,
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
        'workflow' => array('any'),
      ),
    ),
    'workflow_select_given_state_action' => array(
      'type' => 'node',
      'description' => t('Change workflow state of post to new state'),
      'configurable' => TRUE,
      'hooks' => array(
        'nodeapi' => array('presave'),
        'comment' => array('insert', 'update'),
        'workflow' => array('any'),
      ),
    ),
  );
}

/**
 * Implementation of a Drupal action. Move a node to the next state in the workfow.
 */
function workflow_select_next_state_action($node, $context) {
  // If this action is being fired because it's attached to a workflow transition
  // then the node's new state (now its current state) should be in $node->workflow
  // because that is where the value from the workflow form field is stored;
  // otherwise the current state is placed in $node->_workflow by our nodeapi load.
  if (!isset($node->workflow) && !isset($node->_workflow)) {
    watchdog('workflow', 'Unable to get current workflow state of node %nid.', array('%nid' => $node->nid));
    return;
  }
  $current_state = isset($node->workflow) ? $node->workflow : $node->_workflow;

  // Get the node's new state.
  $choices = workflow_field_choices($node);
  foreach ($choices as $state_name => $label) {
    if (isset($flag)) {
      $new_state = $state_name;
      $new_state_label = $label;
      break;
    }
    if ($state_name == $current_state) {
      $flag = TRUE;
    }
  }

  // Fire the transition.
  workflow_execute_transition($node, $new_state);
}

/**
 * Implementation of a Drupal action. Move a node to a specified state.
 */
function workflow_select_given_state_action($node, $context) {
  $t_args = array(
    '%title' => check_plain($node->title),
    '%state' => check_plain($context['label']),
  );
  $comment = t($context['workflow_comment'], $t_args);
  workflow_execute_transition($node, $context['target_state_name'], $comment, $context['force']);
}

/**
 * Configuration form for "Change workflow state of post to new state" action.
 *
 * @see workflow_select_given_state_action()
 */
function workflow_select_given_state_action_form($context) {
  $result = db_query("SELECT w.label AS workflow_label, ws.name AS state_name, ws.label AS state_label "
    . "FROM {workflow_states} ws "
    . "LEFT JOIN {workflows} w ON ws.workflow_name = w.name "
    . "WHERE ws.sysid = 0 AND ws.status = 1 "
    . "ORDER BY ws.workflow_name, ws.weight");
  $previous_workflow = '';
  $options = array();
  while ($data = db_fetch_object($result)) {
    $workflow_label = check_plain(t($data->workflow_label));
    $options[$workflow_label][$data->state_name] = check_plain(t($data->state_label));;
  }
  $form['target_state_name'] = array(
    '#type' => 'select',
    '#title' => t('Target state'),
    '#description' => t('Please select that state that should be assigned when this action runs.'),
    '#default_value' => isset($context['target_state']) ? $context['target_state'] : '',
    '#options' => $options,
  );
  $form['force'] = array(
    '#type' => 'checkbox',
    '#title' => t('Force transition'),
    '#description' => t('If this box is checked, the new state will be assigned even if workflow permissions disallow it.'),
    '#default_value' => isset($context['force']) ? $context['force'] : '',
  );
  $form['workflow_comment'] = array(
    '#type' => 'textfield',
    '#title' => t('Message'),
    '#description' => t('This message will be written into the workflow history log when the action runs. You may include the following variables: %state, %title'),
    '#default_value' => isset($context['workflow_history']) ? $context['workflow_history'] : t('Action set %title to %state.'),
  );
  return $form;
}

/**
 * Submit handler for "Change workflow state of post to new state" action
 * configuration form.
 *
 * @see workflow_select_given_state_action_form()
 */
function workflow_select_given_state_action_submit($form_id, $form_state) {
  $label = workflow_get_state_label($form_state['values']['target_state_name']);
  return array(
    'target_state_name' => $form_state['values']['target_state_name'],
    'label' => $label,
    'force' => $form_state['values']['force'],
    'workflow_comment' => $form_state['values']['workflow_comment'],
  );
}

/**
 * Get the states current user can move to for a given node.
 *
 * @param object $node
 *   The node to check.
 * @return
 *   Array of transitions.
 */
function workflow_field_choices($node) {
  global $user;
  $name = workflow_get_workflow_for_type($node->type);
  if (!$name) {
    // No workflow for this type.
    return array();
  }

  $roles = array_keys($user->roles);
  $current_state = workflow_node_current_state($node);

  // If user is node author or this is a new page, give the authorship role.
  if (($user->uid == $node->uid && $node->uid > 0) || (arg(0) == 'node' && arg(1) == 'add')) {
    $roles += array('author' => 'author');
  }
  if ($user->uid == 1) {
    // Superuser is special.
    $roles = 'ALL';
  }
  $transitions = workflow_allowable_transitions($current_state, 'to', $roles);

  // Include current state if it is not the (creation) state.
  if ($current_state == _workflow_creation_state($name)) {
    unset($transitions[$current_state]);
  }
  return $transitions;
}

/**
 * Get the current state of a given node.
 *
 * @param $node
 *   The node to check.
 * @return
 *   The machine name of the current state.
 */
function workflow_node_current_state($node) {
  $state_name = FALSE;

  // There is no nid when creating a node.
  if (!empty($node->nid)) {
    $state_name = db_result(db_query('SELECT state_name FROM {workflow_node} WHERE nid = %d', $node->nid));
  }

  if (!$state_name && !empty($node->type)) {
    // No current state. Use creation state.
    $name = workflow_get_workflow_for_type($node->type);
    $state_name = _workflow_creation_state($name);
  }
  return $state_name;
}

/**
 * Helper function to generate a creation state name.
 *
 * @param $name
 *   The machine name of the workflow.
 */
function _workflow_creation_state($name) {
  return $name .'_'. WORKFLOW_CREATION_NAME;
}

/**
 * Implementation of hook_workflow().
 *
 * @param $op
 *   The current workflow operation: 'transition pre' or 'transition post'.
 * @param $old_state
 *   The state ID of the current state.
 * @param  $new_state
 *   The state ID of the new state.
 * @param $node
 *   The node whose workflow state is changing.
 */
function workflow_workflow($op, $old_state, $new_state, $node) {
  switch ($op) {
    case 'transition pre':
      // The workflow module does nothing during this operation.
      // But your module's implementation of the workflow hook could
      // return FALSE here and veto the transition.
      break;

    case 'transition post':
      // A transition has occurred; fire off actions associated with this transition.
      // Can't fire actions if trigger module is not enabled.
      if (!module_exists('trigger')) {
        break;
      }
      $tid = workflow_get_transition_id($old_state, $new_state);
      $op = 'workflow-'. $node->type .'-'. $tid;
      $aids = _trigger_get_hook_aids('workflow', $op);
      if ($aids) {
        $context = array(
          'hook' => 'workflow',
          'op' => $op,
        );

        // We need to get the expected object if the action's type is not 'node'.
        // We keep the object in $objects so we can reuse it if we have multiple actions
        // that make changes to an object.
        foreach ($aids as $aid => $action_info) {
          if ($action_info['type'] != 'node') {
            if (!isset($objects[$action_info['type']])) {
              $objects[$action_info['type']] = _trigger_normalize_node_context($action_info['type'], $node);
            }
            // Pass the node as the object for actions of type 'system'.
            if (!isset($objects[$action_info['type']]) && $action_info['type'] == 'system') {
              $objects[$action_info['type']] = $node;
            }
            // Since we know about the node, we pass that info along to the action.
            $context['node'] = $node;
            $result = actions_do($aid, $objects[$action_info['type']], $context);
          }
          else {
            actions_do($aid, $node, $context);
          }
        }
      }
      break;
  }
}

/**
 * Load function.
 *
 * @param $name
 *   The machine name of the workflow to load.
 * @return $workflow
 *   Object representing the workflow.
 */
function workflow_load($name) {
  $workflow = db_fetch_object(db_query("SELECT * FROM {workflows} WHERE name = '%s'", $name));
  $workflow->options = unserialize($workflow->options);
  return $workflow;
}

/**
 * Update the transitions for a workflow.
 *
 * @param array $transitions
 *   Transitions, for example:
 *     18 => array(
 *       20 => array(
 *         'author' => 1,
 *         1        => 0,
 *         2        => 1,
 *       )
 *     )
 *   means the transition from state 18 to state 20 can be executed by
 *   the node author or a user in role 2. The $transitions array should
 *   contain ALL transitions for the workflow.
 */
function workflow_update_transitions($transitions = array()) {
  // Empty string is sometimes passed in instead of an array.
  if (!$transitions) {
    return;
  }

  foreach ($transitions as $from => $to_data) {
    foreach ($to_data as $to => $role_data) {
      foreach ($role_data as $role => $can_do) {
        if ($can_do) {
          workflow_transition_add_role($from, $to, $role);
        }
        else {
          workflow_transition_delete_role($from, $to, $role);
        }
      }
    }
  }
  db_query("DELETE FROM {workflow_transitions} WHERE roles = ''");
}

/**
 * Add a role to the list of those allowed for a given transition.
 *
 * Add the transition if necessary.
 *
 * @param $from
 *   The machine name of the originating state.
 * @param $to
 *   The machine name of the target state.
 * @param mixed $role
 *   Int (role ID) or string ('author').
 */
function workflow_transition_add_role($from, $to, $role) {
  $transition = array(
    'state_name' => $from,
    'target_state_name' => $to,
    'roles' => $role,
  );
  $tid = workflow_get_transition_id($from, $to);
  if ($tid) {
    $roles = db_result(db_query("SELECT roles FROM {workflow_transitions} WHERE tid=%d", $tid));
    $roles = explode(',', $roles);
    if (array_search($role, $roles) === FALSE) {
      $roles[] = $role;
      $transition['roles'] = implode(',', $roles);
      $transition['tid'] = $tid;
      drupal_write_record('workflow_transitions', $transition, 'tid');
    }
  }
  else {
    drupal_write_record('workflow_transitions', $transition);
  }
}

/**
 * Remove a role from the list of those allowed for a given transition.
 *
 * @param $from
 *   The machine name of the originating state.
 * @param $to
 *   The machine name of the target state.
 * @param mixed $role
 *   Int (role ID) or string ('author').
 */
function workflow_transition_delete_role($from, $to, $role) {
  $tid = workflow_get_transition_id($from, $to);
  if ($tid) {
    $roles = db_result(db_query("SELECT roles FROM {workflow_transitions} WHERE tid=%d", $tid));
    $roles = explode(',', $roles);
    if (($i = array_search($role, $roles)) !== FALSE) {
      unset($roles[$i]);
      db_query("UPDATE {workflow_transitions} SET roles='%s' WHERE tid=%d", implode(',', $roles), $tid);
    }
  }
}

/**
 * See if a transition is allowed for a given role.
 *
 * @param int $tid
 * @param mixed $role
 *   A single role (int or string 'author') or array of roles.
 * @return
 *   TRUE if the role is allowed to do the transition.
 */
function workflow_transition_allowed($tid, $role = NULL) {
  $allowed = db_result(db_query("SELECT roles FROM {workflow_transitions} WHERE tid = %d", $tid));
  $allowed = explode(',', $allowed);
  if ($role) {
    if (!is_array($role)) {
      $role = array($role);
    }
    return array_intersect($role, $allowed) ==  TRUE;
  }
}

/**
 * Tell caller whether a state is a protected system state, such as the creation state.
 *
 * @param $state
 *   The label of the state to test
 * @return
 *   TRUE if the state is a system state.
 */
function workflow_is_system_state($state) {
  static $states;
  if (!isset($states)) {
    $states = array(t('(creation)') => TRUE);
  }
  return isset($states[$state]);
}

/**
 * Given the machine name of a workflow, return its label.
 *
 * @param string $name
 *   The machine name of the workflow.
 * @return string
 *   The name of the workflow.
 */
function workflow_get_label($name) {
  $label = db_result(db_query("SELECT label FROM {workflows} WHERE name = '%s'", $name));
  return check_plain(t($label));
}

/**
 * Get ID of a workflow for a node type.
 *
 * @param $type
 *   Machine readable node type name, e.g. 'story'.
 * @return string
 *   The machine name of the workflow or FALSE if no workflow is mapped to this type.
 */
function workflow_get_workflow_for_type($type) {
  static $cache;

  if(empty($cache[$type])) {
    $sql = "SELECT workflow_name FROM {workflow_type_map} WHERE type = '%s'";
    $cache[$type] = db_result(db_query($sql, $type));
  }

  return empty($cache[$type]) ? FALSE : $cache[$type];
}

/**
 * Get all workflows.
 *
 * @param $reset
 *   Boolean to clear the static cache.
 * @return
 *   An array of workflows.
 */
function workflow_get_all($reset = FALSE) {
  static $workflows;

  if (is_null($workflows) || $reset) {
    $workflows = array();

    $result = db_query("SELECT * FROM {workflows} ORDER BY label ASC");
    while ($data = db_fetch_object($result)) {
      $data->label = check_plain(t($data->label));
      $workflows[$data->name] = $data;
    }
  }

  return $workflows;
}

/**
 * Get all workflow labels.
 *
 * @return
 *   An array of workflow names.
 */
function workflow_get_all_labels() {
  $workflows = workflow_get_all();

  foreach ($workflows as $key => $workflow) {
    $workflows[$key] = $workflow->label;
  }

  return $workflows;
}

/**
 * Create a workflow and its (creation) state.
 *
 * @param $workflow
 *   An array of values needed to create a workflow.
 * @return
 *   The saved workflow object.
 */
function workflow_create($workflow) {
  $default = array('options' => array('comment_log_node' => 1, 'comment_log_tab' => 1));
  $workflow += $default;

  $workflow = (object) $workflow;

  if (drupal_write_record('workflows', $workflow)) {
    $state = array(
      'name' => _workflow_creation_state($workflow->name),
      'workflow_name' => $workflow->name,
      'label' => t('(creation)'),
      'sysid' => WORKFLOW_CREATION,
      'weight' => WORKFLOW_CREATION_DEFAULT_WEIGHT,
    );
    workflow_state_save($state);
    // Workflow creation affects tabs (local tasks), so force menu rebuild.
    menu_rebuild();
  }

  return $workflow;
}

/**
 * Update an existing workflow.
 *
 * @param $workflow
 *   The workflow object to update.
 * @return
 *   The updated workflow object.
 */
function workflow_update($workflow) {
  $workflow = drupal_write_record('workflows', $workflow, 'wid');

  // Workflow name change affects tabs (local tasks), so force menu rebuild.
  menu_rebuild();

  return $workflow;
}

/**
 * Delete a workflow from the database. Deletes all states,
 * transitions and node type mappings, too. Removes workflow state
 * information from nodes participating in this workflow.
 *
 * @param $name
 *   The machine name of the workflow.
 */
function workflow_deletewf($name) {
  $result = db_query("SELECT * FROM {workflow_states} WHERE workflow_name = '%s'", $name);
  while ($state = db_fetch_object($result)) {
    // Delete the state and any associated transitions and actions.
    workflow_state_delete($state->name);
    db_query("DELETE FROM {workflow_node} WHERE state_name = '%s'", $state->name);
  }
  db_query("DELETE FROM {workflow_type_map} WHERE workflow_name = '%s'", $name);
  db_query("DELETE FROM {workflows} WHERE name = '%s'", $name);
  // Notify any interested modules.
  module_invoke_all('workflow', 'workflow delete', $name, NULL, NULL);
  // Workflow deletion affects tabs (local tasks), so force menu rebuild.
  cache_clear_all('*', 'cache_menu', TRUE);
  menu_rebuild();
}

/**
 * Load workflow states for a workflow from the database. If $machine_name is 
 * not passed, all states for all workflows are given. States that have been 
 * deleted are not included.
 *
 * @param $workflow_name
 *   The machine name of the workflow.
 * @param $all
 *   If TRUE, will return all workflows, regardless of status.
 * @return
 *   An array of workflow states.
 */
function workflow_get_states($workflow_name = NULL, $all = FALSE) {
  $states = array();

  if (isset($workflow_name) && $all) {
    $query = "SELECT * FROM {workflow_states} WHERE workflow_name = '%s' ORDER BY weight, label";
    $result = db_query($query, $workflow_name);
  }
  else if (isset($workflow_name)) {
    $query = "SELECT * FROM {workflow_states} WHERE workflow_name = '%s' AND status = 1 ORDER BY weight, label";
    $result = db_query($query, $workflow_name);
  }
  else if ($all) {
    $query = "SELECT * FROM {workflow_states} ORDER BY weight, label";
    $result = db_query($query);
  }
  else {
    $query = "SELECT * FROM {workflow_states} WHERE status = 1 ORDER BY weight, label";
    $result = db_query($query);
  }

  while ($data = db_fetch_object($result)) {
    if (is_null($workflow_name)) {
      $workflow = workflow_load($data->workflow_name);
      $data->label = $workflow->label .': '. $data->label;
    }
    $data->label = check_plain(t($data->label));
    $states[$data->name] = $data;
  }

  return $states;
}

/**
 * Load workflow state names for a workflow from the database. If $workflow_name 
 * is not passed, all states for all workflows are given. States that have been 
 * deleted are not included.
 *
 * @param $workflow_name
 *   The machine name of the workflow.
 * @param $all
 *   If TRUE, will return all workflows, regardless of status.
 * @return
 *   An array of workflow states.
 */
function workflow_get_state_labels($workflow_name = NULL, $all = FALSE) {
  $states = workflow_get_states($workflow_name, $all);

  foreach ($states as $name => $state) {
    $states[$name] = $state->label;
  }

  return $states;
}

/**
 * Given the machine name of a workflow state, return a keyed array representing
 * the state.
 *
 * @param $name
 *   The machine name of the workflow state.
 * @param $active_only
 *   Boolean to indicate to only return active states. Defaults to FALSE.
 * @return
 *   The workflow state object.
 */
function workflow_get_state($name, $active_only = FALSE) {
  $sql = "SELECT * FROM {workflow_states} WHERE name = '%s'";

  if ($active_only) {
    $sql .= " AND status = 1";
  }
  
  $result = db_query($sql, $name);
  // State IDs are unique, so there should be only one row.
  if ($state = db_fetch_object($result)) {
    $state->label = check_plain(t($state->label));
  }

  return $state;
}

/**
 * Given the ID of a state, return its name.
 *
 * @param integer $sid
 *   The ID of the workflow state.
 * @return string
 *   The name of the workflow state.
 */
function workflow_get_state_label($sid) {
  return db_result(db_query('SELECT label FROM {workflow_states} WHERE sid = %d', $sid));
}


/**
 * Add or update a workflow state to the database.
 *
 * @param $edit
 *   An array containing values for the new or updated workflow state.
 * @return
 *   The ID of the new or updated workflow state.
 */
function workflow_state_save($state) {
  if (!isset($state['sid'])) {
    drupal_write_record('workflow_states', $state);
  }
  else {
    drupal_write_record('workflow_states', $state, 'sid');
  }

  return $state;
}

/**
 * Delete a workflow state from the database, including any
 * transitions the state was involved in and any associations
 * with actions that were made to that transition.
 *
 * @param $name
 *   The machine name of the state to delete.
 * @param $new_name
 *   Deleting a state will leave any nodes to which that state is assigned
 *   without a state. If $new_state is given, it will be assigned to those
 *   orphaned nodes.
 */
function workflow_state_delete($name, $new_name = NULL) {
  if ($new_name && $new_state = workflow_get_state($new_name)) {
    // Assign nodes to new state so they are not orphaned.
    // A candidate for the batch API.
    $node = new stdClass();
    $node->workflow_stamp = time();
    $result = db_query("SELECT nid FROM {workflow_node} WHERE state_name = '%s'", $name);
    while ($data = db_fetch_object($result)) {
      $node->nid = $data->nid;
      $node->_workflow = $name;
      _workflow_write_history($node, $new_name, t('Previous state deleted'));
      db_query("UPDATE {workflow_node} SET state_name = '%s' WHERE nid = %d AND state_name = '%s'", $new_name, $data->nid, $name);
    }
  }
  else {
    // Go ahead and orphan nodes.
    db_query("DELETE from {workflow_node} WHERE state_name = '%s'", $name);
  }

  // Delete all associated transitions this state is involved in.
  $result = db_query("SELECT tid FROM {workflow_transitions} WHERE state_name = '%s' OR target_state_name = '%s'", $name, $name);
  while ($data = db_fetch_object($result)) {
    workflow_transition_delete($data->tid);
  }

  // Disable the state.
  db_query("UPDATE {workflow_states} SET status = 0 WHERE name = '%s'", $name);
  // Notify interested modules.
  module_invoke_all('workflow', 'state delete', $name, NULL, NULL);
}

/**
 * Delete a transition (and any associated actions).
 *
 * @param $tid
 *   The ID of the transition.
 */
function workflow_transition_delete($tid) {
  $actions = workflow_get_actions($tid);
  foreach ($actions as $aid => $type) {
    workflow_actions_remove($tid, $aid);
  }
  db_query("DELETE FROM {workflow_transitions} WHERE tid = %d", $tid);
  // Notify interested modules.
  module_invoke_all('workflow', 'transition delete', $tid, NULL, NULL);
}

/**
 * Get allowable transitions for a given workflow state. Typical use:
 *
 * global $user;
 * $possible = workflow_allowable_transitions($state_name, 'to', $user->roles);
 *
 * If the state name corresponded to the state named "Draft", $possible now
 * contains the states that the current user may move to from the Draft state.
 *
 * @param $state_name
 *   The machine name of the state in question.
 * @param $dir
 *   The direction of the transition: 'to' or 'from' the state denoted by
 *   $state_name. When set to 'to' all the allowable states that may be moved to
 *   are returned; when set to 'from' all the allowable states that may move to
 *   the current state are returned.
 * @param mixed $roles
 *   Array of ints (and possibly the string 'author') representing the user's
 *   roles. If the string 'ALL' is passed (instead of an array) the role
 *   constraint is ignored (this is the default for backwards compatibility).
 *
 * @return
 *   Associative array of states ($state_name => $state_label pairs), excluding
 *   current state.
 */
function workflow_allowable_transitions($state_name, $dir = 'to', $roles = 'ALL') {
  $transitions = array();

  if ($dir == 'to') {
    $field = 'target_state_name';
    $field_where = 'state_name';
  }
  else {
    $field = 'state_name';
    $field_where = 'target_state_name';
  }

  $result = db_query(
    "(SELECT t.tid, t.%s as state_name, s.label AS state_label, s.weight AS state_weight "
    . "FROM {workflow_transitions} t "
    . "INNER JOIN {workflow_states} s "
    . "ON s.name = t.%s "
    . "WHERE t.%s = '%s' AND s.status = 1 "
    . "ORDER BY state_weight) "
    . "UNION "
    . "(SELECT s.sid as tid, s.name as state_name, s.label as state_label, s.weight as state_weight "
    . "FROM {workflow_states} s "
    . "WHERE s.name = '%s' AND s.status = 1) "
    . "ORDER BY state_weight, state_name", $field, $field, $field_where, $state_name, $state_name);
  while ($t = db_fetch_object($result)) {
    if ($roles == 'ALL'  // Superuser.
      || $state_name == $t->state_name // Include current state for same-state transitions.
      || workflow_transition_allowed($t->tid, $roles)) {
      $transitions[$t->state_name] = check_plain(t($t->state_label));
    }
  }

  return $transitions;
}

/**
 * Save mapping of workflow to node type. E.g., "the story node type
 * is using the Foo workflow."
 *
 * @param $form_state['values']
 */
function workflow_types_save($form_values) {
  db_query("DELETE FROM {workflow_type_map}");
  $node_types = node_get_types();
  foreach ($node_types as $type => $name) {
    db_query("INSERT INTO {workflow_type_map} (type, workflow_name) VALUES ('%s', '%s')", $type, $form_values[$type]['workflow_name']);
    variable_set('workflow_' . $type, array_keys(array_filter(($form_values[$type]['placement']))));
  }
}

/**
 * Get the actions associated with a given transition.
 *
 * @see _trigger_get_hook_aids()
 *
 * @param int $tid
 *   ID of transition.
 * @return array
 *   Array of action ids in the same format as _trigger_get_hook_aids().
 */
function workflow_get_actions($tid) {
  $aids = array();
  if (!module_exists('trigger')) {
    watchdog('workflow', 'Unable to get actions associated with a transition because the trigger module is not enabled.', array(), WATCHDOG_WARNING);
    return $aids;
  }

  $result = db_query("SELECT op FROM {trigger_assignments} WHERE hook = 'workflow'");
  while ($data = db_fetch_object($result)) {
    // Transition ID is the last part, e.g., foo-bar-1.
    $transition = array_pop(explode('-', $data->op));
    if ($tid == $transition) {
      $results = db_query("SELECT aa.aid, a.type FROM {trigger_assignments} aa LEFT JOIN {actions} a ON aa.aid = a.aid WHERE aa.hook = '%s' AND aa.op = '%s' ORDER BY weight", 'workflow', $data->op);
      while ($action = db_fetch_object($results)) {
        $aids[$action->aid]['type'] = $action->type;
      }
    }
  }

  return $aids;
}

/**
 * Get the tid of a transition, if it exists.
 *
 * @param $from
 *   The machine name of the originating state.
 * @param $to
 *   The machine name of the target state.
 * @return int
 *   Tid or FALSE if no such transition exists.
 */
function workflow_get_transition_id($from, $to) {
  return db_result(db_query("SELECT tid FROM {workflow_transitions} WHERE state_name = '%s' AND target_state_name = '%s'", $from, $to));
}

/**
 * Remove an action assignment programmatically.
 *
 * Helpful when deleting a workflow.
 *
 * @see workflow_transition_delete()
 *
 * @param $tid
 *   Transition ID.
 * @param $aid
 *   Action ID.
 */
function workflow_actions_remove($tid, $aid) {
  $ops = array();
  $result = db_query("SELECT op FROM {trigger_assignments} WHERE hook = 'workflow' AND aid = '%s'", $aid);
  while ($data = db_fetch_object($result)) {
    // Transition ID is the last part, e.g., foo-bar-1.
    $transition = array_pop(explode('-', $data->op));
    if ($tid == $transition) {
      $ops[] = $data->op;
    }
  }

  foreach ($ops as $op) {
    db_query("DELETE FROM {trigger_assignments} WHERE hook = 'workflow' AND op = '%s' AND aid = '%s'", $op, $aid);
    $description = db_result(db_query("SELECT description FROM {actions} WHERE aid = '%s'", $aid));
    watchdog('workflow', 'Action %action has been unassigned.',  array('%action' => $description));
  }
}

/**
 * Put a node into a state.
 * No permission checking here; only call this from other functions that know
 * what they're doing.
 *
 * @see workflow_execute_transition()
 *
 * @param object $node
 * @param $state_name
 *   The machine name of the target state.
 */
function _workflow_node_to_state($node, $state_name, $comment = NULL) {
  global $user;
  $node->workflow_stamp = time();
  if (db_result(db_query("SELECT nid FROM {workflow_node} WHERE nid = %d", $node->nid))) {
    db_query("UPDATE {workflow_node} SET state_name = '%s', uid = %d, stamp = %d WHERE nid = %d", $state_name, $user->uid, $node->workflow_stamp, $node->nid);
  }
  else {
    db_query("INSERT INTO {workflow_node} (nid, state_name, uid, stamp) VALUES (%d, '%s', %d, %d)", $node->nid, $state_name, $user->uid, $node->workflow_stamp);
  }
  _workflow_write_history($node, $state_name, $comment);
}

/**
 * Write the node history record to workflow_node_history.
 */
function _workflow_write_history($node, $state_name, $comment) {
  global $user;
  db_query("INSERT INTO {workflow_node_history} (nid, old_state_name, state_name, uid, comment, stamp) VALUES (%d, '%s', '%s', %d, '%s', %d)", $node->nid, $node->_workflow, $state_name, $user->uid, $comment, $node->workflow_stamp);
}

/**
 * Get a list of roles.
 *
 * @return
 *   Array of role names keyed by role ID, including the 'author' role.
 */
function workflow_get_roles() {
  static $roles = NULL;
  if (!$roles) {
    $result = db_query('SELECT * FROM {role} ORDER BY name');
    $roles = array('author' => 'author');
    while ($data = db_fetch_object($result)) {
      $roles[$data->rid] = check_plain($data->name);
    }
  }
  return $roles;
}

/**
 * Implementation of hook_cron().
 */
function workflow_cron() {
  $clear_cache = FALSE;

  // If the time now is greater than the time to execute a
  // transition, do it.
  $nodes = db_query('SELECT * FROM {workflow_scheduled_transition} s WHERE s.scheduled > 0 AND s.scheduled < %d', time());

  while ($row = db_fetch_object($nodes)) {
    $node = node_load($row->nid);

    // Make sure transition is still valid; i.e., the node is
    // still in the state it was when the transition was scheduled.
    if ($node->_workflow == $row->old_state_name) {
      // Do transition.
      workflow_execute_transition($node, $row->state_name, $row->comment, TRUE);

      watchdog('content', '%type: scheduled transition of %title.', array('%type' => t($node->type), '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), 'node/'. $node->nid));
      $clear_cache = TRUE;
    }
    else {
      // Node is not in the same state it was when the transition
      // was scheduled. Defer to the node's current state and
      // abandon the scheduled transition.
      db_query('DELETE FROM {workflow_scheduled_transition} WHERE nid = %d', $node->nid);
    }
  }

  if ($clear_cache) {
    // Clear the cache so that if the transition resulted in a node
    // being published, the anonymous user can see it.
    cache_clear_all();
  }
}

/**
 * Implementation of action_info_alter().
 */
function workflow_action_info_alter(&$info) {
  foreach (array_keys($info) as $key) {
    // Modify each action's hooks declaration, changing it to say
    // that the action supports any hook.
    $info[$key]['hooks']['any'] = TRUE;
  }
}

/**
 * Implementation of hook_hook_info().
 * Expose each transition as a hook.
 */
function workflow_hook_info() {
  $states = workflow_get_states();
  if (!$states) {
    return;
  }

  $trigger_page = substr($_GET['q'], 0, 28) == 'admin/build/trigger/workflow';
  if ($trigger_page && $workflow_name = arg(4)) {
    $result = db_query("SELECT tm.type, w.name, w.label, wt.tid, wt.state_name, wt.target_state_name "
      . "FROM {workflow_type_map} tm "
      . "LEFT JOIN {workflows} w ON tm.workflow_name = w.name "
      . "LEFT JOIN {workflow_states} ws ON w.name = ws.workflow_name "
      . "LEFT JOIN {workflow_transitions} wt ON ws.name = wt.state_name "
      . "WHERE w.name = '%s' AND wt.target_state_name IS NOT NULL "
      . "ORDER BY tm.type, ws.weight", $workflow_name);
  }
  else {
    $result = db_query("SELECT tm.type, w.name, w.label, wt.tid, wt.state_name, wt.target_state_name "
      . "FROM {workflow_type_map} tm "
      . "LEFT JOIN {workflows} w ON tm.workflow_name = w.name "
      . "LEFT JOIN {workflow_states} ws ON w.name = ws.workflow_name "
      . "LEFT JOIN {workflow_transitions} wt ON ws.name = wt.state_name "
      . "WHERE wt.target_state_name IS NOT NULL "
      . "ORDER BY tm.type, ws.weight");
  }
  while ($data = db_fetch_object($result)) {
    $state = $states[$data->state_name];
    $target_state = $states[$data->target_state_name];
    $t_args = array('%type' => $data->type, '%state' => $state->label, '%target_state' => $target_state->label);
    $hook_key = 'workflow-'. $data->type .'-'. $data->tid;
    $pseudohooks[$hook_key] = array('runs when' => t('When %type moves from %state to %target_state', $t_args));
  }
  // $pseudohooks will not be set if no workflows have been assigned
  // to node types.
  if (isset($pseudohooks)) {
    return array(
      'workflow' => array(
        'workflow' => $pseudohooks,
      ),
    );
  }
  if ($trigger_page) {
    drupal_set_message(t('Either no transitions have been set up or this workflow has not yet been assigned to a content type. To enable the assignment of actions, edit the workflow to assign permissions for roles to do transitions. After that is completed, transitions will appear here and you will be able to assign actions to them.'));
  }
}

/**
 * Implementation of hook_menu_alter().
 *
 * Work around loss of menu local task inheritance in Drupal 6.2.
 */
function workflow_menu_alter(&$callbacks) {
  if (module_exists('trigger') & isset($callbacks['admin/build/trigger/workflow'])) {
    $callbacks['admin/build/trigger/workflow']['access callback'] = 'trigger_access_check';
  }
}

/**
 * Implementation of hook_token_values().
 */
function workflow_token_values($type, $object = NULL) {
  $values = array();
  switch ($type) {
    case 'node':
    case 'workflow':
      $node = (object)$object;

      if ($machine_name = workflow_get_workflow_for_type($node->type)) {
        $workflow = workflow_load($machine_name);
        $values['workflow-name'] = $workflow->label;
        $values['workflow-machine-name'] = $machine_name;
        $states = workflow_get_states($machine_name);
      }
      else {
        break;
      }

      $result = db_query_range("SELECT h.* FROM {workflow_node_history} h WHERE nid = %d ORDER BY stamp DESC", $node->nid, 0, 1);

      if ($row = db_fetch_object($result)) {
        $account = user_load(array('uid' => $row->uid));
        $comment = $row->comment;
      }

      if (isset($node->workflow) && !isset($node->workflow_stamp)) {
        // The node is being submitted but the form data has not been saved to the database yet,
        // so we set the token values from the workflow form fields.
        $state_name = $node->workflow;
        $old_state_name = isset($row->state_name) ? $row->state_name : _workflow_creation_state($machine_name);
        $date = time();
        $user_name = $node->uid ? $node->name : variable_get('anonymous', 'Anonymous');
        $uid = $node->uid;
        $mail = $node->uid ? $node->user_mail : '';
        $comment = $node->workflow_comment;
      }
      else if (!isset($node->workflow) && empty($row->state_name)) {
        // If the state is not specified and the node has no workflow history,
        // the node is being inserted and will soon be transitioned to the first valid state.
        // We find this state using the same logic as workflow_nodeapi().
        $choices = workflow_field_choices($node);
        $keys = array_keys($choices);
        $state_name = array_shift($keys);
        $old_state_name = _workflow_creation_state($machine_name);
        $date = time();
        $user_name = $node->uid ? $node->name : variable_get('anonymous', 'Anonymous');
        $uid = $node->uid;
        $mail = $node->uid ? $node->user_mail : '';
        $comment = $node->workflow_comment;
      }
      else {
        // Default to the most recent transition data in the workflow history table.
        $state_name = $row->state_name;
        $old_state_name = $row->old_state_name;
        $date = $row->stamp;
        $user_name = $account->uid ? $account->name : variable_get('anonymous', 'Anonymous');
        $uid = $account->uid;
        $mail = $account->uid ? $account->mail : '';
      }

      $values['workflow-current-state-name']                =  $states[$state_name]->label;
      $values['workflow-old-state-name']                    =  $states[$old_state_name]->label;

      $values['workflow-current-state-date-iso']            =  date('Ymdhis', $date);
      $values['workflow-current-state-date-tstamp']         =  $date;
      $values['workflow-current-state-date-formatted']      =  date('M d, Y h:i:s', $date);

      $values['workflow-current-state-updating-user-name']  = check_plain($user_name);
      $values['workflow-current-state-updating-user-uid']   = $uid;
      $values['workflow-current-state-updating-user-mail']  = check_plain($mail);

      $values['workflow-current-state-log-entry']           = filter_xss($comment, array('a', 'em', 'strong'));
      break;
  }

  return $values;
}

/**
 * Implementation of hook_token_list().
 */
function workflow_token_list($type = 'all') {

  if ($type == 'workflow' || $type == 'node' || $type == 'all') {
    $tokens['workflow']['workflow-name']                          =  'Name of workflow applied to this node';
    $tokens['workflow']['workflow-machine-name']                  =  'Machine name of workflow applied to this node';
    $tokens['workflow']['workflow-current-state-name']            =  'Current state of content';
    $tokens['workflow']['workflow-old-state-name']                =  'Old state of content';
    $tokens['workflow']['workflow-current-state-date-iso']        =  'Date of last state change (ISO)';
    $tokens['workflow']['workflow-current-state-date-tstamp']     =  'Date of last state change (timestamp)';
    $tokens['workflow']['workflow-current-state-date-formatted']  =  'Date of last state change (formatted - M d, Y h:i:s)';;

    $tokens['workflow']['workflow-current-state-updating-user-name']       = 'Username of last state changer';
    $tokens['workflow']['workflow-current-state-updating-user-uid']        = 'uid of last state changer';
    $tokens['workflow']['workflow-current-state-updating-user-mail']       = 'email of last state changer';

    $tokens['workflow']['workflow-current-state-log-entry']       = 'Last workflow comment log';
    $tokens['node'] = $tokens['workflow'];
  }

  return $tokens;
}

/**
 * Implementation of hook_content_extra_fields().
 */
function workflow_content_extra_fields($type_name) {
  $extra = array();
  if (!in_array('node', variable_get('workflow_'. $type_name, array('node')))) {
    return;
  }
  $extra['workflow'] = array(
    'label' => t('Workflow'),
    'description' => t('Workflow module form'),
    'weight' => 10,
  );
  return $extra;
}